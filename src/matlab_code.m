clc;
clear;
close all;

%Read in Reference Values generated by cpp library
RefBw    = csvread('../data/BWPrint.dat');
RefBlur  = csvread('../data/BlurPrint.dat');
RefMag   = csvread('../data/MagPrint.dat');
RefTheta = csvread('../data/ThetaPrint.dat');

bike  = '../pics/bikesgray.jpg';
tag   = '../pics/test_tag.png';
ref   = '../pics/tag_middle.png';
real  = '../pics/real_life_tag.png';
real2 = '../pics/real_life_tag2.jpg';

downscale = 1/255;
Debug_Gradient = 0;
tStart = tic;
image = imread(tag);
figure('Name','Original Image');
imshow(image);
title('Original Image');
%image = double(image);

%Preprocessing to Grayscale
if(ndims(image) > 2)
    image_gray = double(rgb2gray(image))/255;
    %image_gray = NormalizeVals(image_gray);
else
    image_gray = double(image)/255;
    %image_gray = NormalizeVals(image_gray);
end

%image_gray = NormalizeVals(image_gray);
figure('Name','Preprocessing: Grayscale');
imshow([image_gray,RefBw]);
title('Preprocessing: Grayscale');

%Displaying the difference between the two
BwDiff = PercentError(RefBw,image_gray);
figure('Name','% Difference in Grayscale');
imagesc(BwDiff*100);
colorbar;
title('% Difference in Grayscale');
BwTotalErr = sum(sum(BwDiff))*100

%Stage 1: Gaussian Blurring 
image_blurred = imgaussfilt(image_gray, 0.8);

%Displaying the results of blurring
figure('Name','Stage 1:Gaussian Blurring');
imshow([image_blurred,RefBlur]);
title('Stage 1:Gaussian Blurring');

%Displaying the difference between the two
BlurDiff = PercentError(RefBlur,image_blurred);
figure('Name','% Difference in Blurring');
imagesc(BlurDiff*100);
colorbar;
title('% Difference in Blurring');
BlurTotalErr = sum(sum(BlurDiff))*100


%Stage 2: Calculating Gradients (Without toolbox)
G = fspecial('gaussian',3,0.5); %Generate Gausian Filter
[dx, dy] = gradient(G);         %Calc Gradient of Gausian
Ix = conv2(RefBlur,dx,'same');
Iy = conv2(RefBlur,dy,'same');

if(Debug_Gradient == 1)
    Ixn = NormalizeVals(Ix);
    Iyn = NormalizeVals(Iy);
    figure('Name','Stage 2a(Debug): Gradient Magnitue (x direction)');
    imshow(Ixn);
    title('Stage 2a: Gradient Magnitue (x direction)');
    figure('Name','Stage 2a(Debug): Gradient Magnitue (y direction)');
    imshow(Iyn);
    title('Stage 2a: Gradient Magnitue (y direction)');
end

gm = single(sqrt(Ix.^2 + Iy.^2));   %Magnitude
gd = single(atan2(Iy,Ix));          %Direction

%[gm, gd]  = imgradient(image_blurred);


figure('Name','Stage 2a: Gradient Magnitue');
imagesc([gm,RefMag]);
colorbar;
title('Stage 2a: Gradient Magnitue');
figure('Name','Stage 2b: Gradient Direction');
imagesc([gd,RefTheta]);
colorbar;
title('Stage 2b: Gradient Direction');
tStep2 = toc(tStart)

MagDiff = PercentError(RefMag,gm);
figure('Name','% Difference in Magnitude');
imagesc(MagDiff*100);
colorbar;
title('% Difference in Magnitude');
MagTotalErr = sum(sum(MagDiff))*100

ThetaDiff = PercentError(RefTheta,gd);
figure('Name','% Difference in Theta');
imagesc(ThetaDiff*100);
colorbar;
title('% Difference in Theta');
BlurTotalErr = sum(sum(ThetaDiff))*100

%Stage 3 + 4: Edge Extraction / Clustering
image_clusters = CalcEdges(ArraytoList(RefMag),ArraytoList(RefTheta),0.004);
tStep3_4 = toc(tStart) - tStep2

Cluster_Num = unique(image_clusters(:,4)); %Gets each unique cluster
current_num = 1; %holds the offset of the where we're grabbing clusters

    figure('Name','Grouped Segments');
    imshow(image_gray);
    title('Grouped Segments');
    hold on;
    for i = 1:size(Cluster_Num)
        num_of_pts = size(find(image_clusters(:,4) == Cluster_Num(i)),1);
        temp = image_clusters(current_num:num_of_pts+current_num - 1,:);
        plot(temp(:,1),temp(:,2),'*');
        current_num = current_num + num_of_pts; %Add to the offset
    end


%Stage 5: Segmentation 
MinCluster = 4;
FoundSegs   = Segmenter(image_clusters,ArraytoList(RefTheta),ArraytoList(RefMag),image_gray);
tStep5 = toc(tStart) - tStep3_4

%Stage 6: Chain Segments
linked_segments = LinkSegs(FoundSegs);
tStep6 = toc(tStart) - tStep5

%Stage 7: Find Quads
quads = QuadDetection(linked_segments,FoundSegs);

    figure('Name','Detected Quads with intersections');
    imshow(image_gray);
    title('Detected Quads with intersections');
    hold on;
    for i = 1:size(quads,1)
        Seg1 = [quads(i,1),quads(i,3); quads(i,2), quads(i,4)];
        Seg2 = [quads(i,3),quads(i,5); quads(i,4), quads(i,6)];
        Seg3 = [quads(i,5),quads(i,7); quads(i,6), quads(i,8)];
        Seg4 = [quads(i,7),quads(i,1); quads(i,8), quads(i,2)];
        
        plot(Seg1(1,:),Seg1(2,:),'r-');
        plot(Seg2(1,:),Seg2(2,:),'r-');
        plot(Seg3(1,:),Seg3(2,:),'r-');
        plot(Seg4(1,:),Seg4(2,:),'r-');
        scatter([quads(i,1),quads(i,3),quads(i,5),quads(i,7)],[quads(i,2),quads(i,4),quads(i,6),quads(i,8)],15,'go');
    end

%Stage 8: Decode Quads
quads = DecodeQuad(quads,FoundSegs,RefBw);

tElapsed = toc(tStart)

function quads = DecodeQuad(quads,FoundSegs,GrayImg)
%Constants to export
blackBorder = 1; dimension = 6;
%GrayImg = GrayImg';
[height,width] = size(GrayImg);

OC = OpticalCenter(width,height);
for i = 1:size(quads,1)
    
    %Initalizing the gray models for this quad
    blackModel = GM_Init();
    whiteModel = GM_Init();
    
    %Initalizing the Homography for this quad
    Quad_H33 = H33_Init(OC);
    Quad_H33 = H33_AddCorrespondence(-1,-1,quads(i,1),quads(i,2),Quad_H33);
    Quad_H33 = H33_AddCorrespondence( 1,-1,quads(i,3),quads(i,4),Quad_H33);
    Quad_H33 = H33_AddCorrespondence( 1, 1,quads(i,5),quads(i,6),Quad_H33);
    Quad_H33 = H33_AddCorrespondence(-1, 1,quads(i,7),quads(i,8),Quad_H33);

    dd = 2 * blackBorder + dimension;

    %Debug figure
    if(i == 3)
        figure('Name','Mapping Points');
        imshow(GrayImg);
        title('Local Mapping points');
        hold on;
    end
    
    for iy = -1:dd
        y = (iy + 0.5) / dd;
        for ix = -1:dd
            x = (ix + 0.5) / dd;
            [px,py,Quad_H33]= Quad_interpolate01(x,y,Quad_H33);
            irx = floor(px + 0.5);
            iry = floor(py + 0.5);
            if(irx < 0 || irx >= width || iry < 0 || iry >= height)
                continue;
            end
            v = GrayImg(iry,irx); %If something seems wrong this is it
            if(i == 3)
                scatter(irx,iry,20,'filled','r');
            end
            if (iy == -1 || iy == dd || ix == -1 || ix == dd)
                whiteModel = GM_addObs(x,y,v,whiteModel);
            elseif (iy == 0 || iy == (dd-1) || ix == 0 || ix == (dd-1))
                blackModel = GM_addObs(x,y,v,blackModel);
            end  
        end
    end
    hold off;

    
    %Debug figure
    if (i == 3)
        figure('Name','Decoding Tag Contents');
        imshow(GrayImg);
        title('Decoding Tag Contents');
        hold on;
    end
    
    bad = false;
    tagCode = uint64(0);
    
    for iy = dimension-1:-1:0
        y = (blackBorder + iy + 0.5)/dd;
        
        for ix = 0:dimension-1
            x = (blackBorder + ix +0.5) /dd;
            [px,py,Quad_H33] = Quad_interpolate01(x,y,Quad_H33);
            irx = floor(px + 0.5);
            iry = floor(py + 0.5);
            if( irx < 0 || irx >= width || iry < 0 || iry >= height)
                bad = true;
                continue;
            end
            [thrBM,blackModel] = GM_interpolate(x,y,blackModel);
            [thrWM,whiteModel] = GM_interpolate(x,y,whiteModel);
            threshold = (thrBM + thrWM) * 0.5;
            v = GrayImg(iry,irx); %If something is wrong look here
            tagCode = bitshift(tagCode,1);
            if( v > threshold)
                tagCode = bitor(tagCode,uint64(1));
            end
            if(i == 3)
                if( v > threshold )
                    scatter(irx,iry,20,'filled','g');
                else
                    scatter(irx,iry,20,'filled','r');
                end
            end
        end
    end
    hold off
    
    if(~bad)
        
    end
end


end

function Homography = H33_Init(OpticalCenter)
Homography = struct('cxy',OpticalCenter,'fA',[],'H',[],'Valid',[]);
Homography.fA = zeros(9);
Homography.H  = zeros(3);
Homography.Valid = false;
end


function H33_struct = H33_AddCorrespondence(Worldx, Worldy, Imagex, Imagey, H33_struct)
H33_struct.Valid = false;
Imagex = Imagex - H33_struct.cxy(1);
Imagey = Imagey - H33_struct.cxy(2);

a03 = -Worldx;
a04 = -Worldy;
a05 = -1;
a06 = Worldx*Imagey;
a07 = Worldy*Imagey;
a08 = Imagey;

H33_struct.fA(4,4) = H33_struct.fA(4,4) + a03*a03;
H33_struct.fA(4,5) = H33_struct.fA(4,5) + a03*a04;
H33_struct.fA(4,6) = H33_struct.fA(4,6) + a03*a05;
H33_struct.fA(4,7) = H33_struct.fA(4,7) + a03*a06;
H33_struct.fA(4,8) = H33_struct.fA(4,8) + a03*a07;
H33_struct.fA(4,9) = H33_struct.fA(4,9) + a03*a08;

H33_struct.fA(5,5) = H33_struct.fA(5,5) + a04*a04;
H33_struct.fA(5,6) = H33_struct.fA(5,6) + a04*a05;
H33_struct.fA(5,7) = H33_struct.fA(5,7) + a04*a06;
H33_struct.fA(5,8) = H33_struct.fA(5,8) + a04*a07;
H33_struct.fA(5,9) = H33_struct.fA(5,9) + a04*a08;
                                          
H33_struct.fA(6,6) = H33_struct.fA(6,6) + a05*a05;
H33_struct.fA(6,7) = H33_struct.fA(6,7) + a05*a06;
H33_struct.fA(6,8) = H33_struct.fA(6,8) + a05*a07;
H33_struct.fA(6,9) = H33_struct.fA(6,9) + a05*a08;
                                          
H33_struct.fA(7,7) = H33_struct.fA(7,7) + a06*a06;
H33_struct.fA(7,8) = H33_struct.fA(7,8) + a06*a07;
H33_struct.fA(7,9) = H33_struct.fA(7,9) + a06*a08;
                                          
H33_struct.fA(8,8) = H33_struct.fA(8,8) + a07*a07;
H33_struct.fA(8,9) = H33_struct.fA(8,9) + a07*a08;
                                          
H33_struct.fA(9,9) = H33_struct.fA(9,9) + a08*a08;

a10 = Worldx;
a11 = Worldy;
a12 = 1;
a16 = -Worldx*Imagex;
a17 = -Worldy*Imagex;
a18 = -Imagex;

H33_struct.fA(1,1) = H33_struct.fA(1,1) + a10*a10;
H33_struct.fA(1,2) = H33_struct.fA(1,2) + a10*a11;
H33_struct.fA(1,3) = H33_struct.fA(1,3) + a10*a12;
H33_struct.fA(1,7) = H33_struct.fA(1,7) + a10*a16;
H33_struct.fA(1,8) = H33_struct.fA(1,8) + a10*a17;
H33_struct.fA(1,9) = H33_struct.fA(1,9) + a10*a18;
                      
H33_struct.fA(2,2) = H33_struct.fA(2,2) + a11*a11;
H33_struct.fA(2,3) = H33_struct.fA(2,3) + a11*a12;
H33_struct.fA(2,7) = H33_struct.fA(2,7) + a11*a16;
H33_struct.fA(2,8) = H33_struct.fA(2,8) + a11*a17;
H33_struct.fA(2,9) = H33_struct.fA(2,9) + a11*a18;
                      
H33_struct.fA(3,3) = H33_struct.fA(3,3) + a12*a12;
H33_struct.fA(3,7) = H33_struct.fA(3,7) + a12*a16;
H33_struct.fA(3,8) = H33_struct.fA(3,8) + a12*a17;
H33_struct.fA(3,9) = H33_struct.fA(3,9) + a12*a18;
                      
H33_struct.fA(7,7) = H33_struct.fA(7,7) + a16*a16;
H33_struct.fA(7,8) = H33_struct.fA(7,8) + a16*a17;
H33_struct.fA(7,9) = H33_struct.fA(7,9) + a16*a18;
                      
H33_struct.fA(8,8) = H33_struct.fA(8,8) + a17*a17;
H33_struct.fA(8,9) = H33_struct.fA(8,9) + a17*a18;
                      
H33_struct.fA(9,9) = H33_struct.fA(9,9) + a18*a18;

a20 = -Worldx*Imagey;
a21 = -Worldy*Imagey;
a22 = -Imagey;
a23 = Worldx*Imagex;
a24 = Worldy*Imagex;
a25 = Imagex;

H33_struct.fA(1,1) = H33_struct.fA(1,1) + a20*a20;
H33_struct.fA(1,2) = H33_struct.fA(1,2) + a20*a21;
H33_struct.fA(1,3) = H33_struct.fA(1,3) + a20*a22;
H33_struct.fA(1,4) = H33_struct.fA(1,4) + a20*a23;
H33_struct.fA(1,5) = H33_struct.fA(1,5) + a20*a24;
H33_struct.fA(1,6) = H33_struct.fA(1,6) + a20*a25;
                                          
H33_struct.fA(2,2) = H33_struct.fA(2,2) + a21*a21;
H33_struct.fA(2,3) = H33_struct.fA(2,3) + a21*a22;
H33_struct.fA(2,4) = H33_struct.fA(2,4) + a21*a23;
H33_struct.fA(2,5) = H33_struct.fA(2,5) + a21*a24;
H33_struct.fA(2,6) = H33_struct.fA(2,6) + a21*a25;
                                          
H33_struct.fA(3,3) = H33_struct.fA(3,3) + a22*a22;
H33_struct.fA(3,4) = H33_struct.fA(3,4) + a22*a23;
H33_struct.fA(3,5) = H33_struct.fA(3,5) + a22*a24;
H33_struct.fA(3,6) = H33_struct.fA(3,6) + a22*a25;
                                          
H33_struct.fA(4,4) = H33_struct.fA(4,4) + a23*a23;
H33_struct.fA(4,5) = H33_struct.fA(4,5) + a23*a24;
H33_struct.fA(4,6) = H33_struct.fA(4,6) + a23*a25;
                                          
H33_struct.fA(5,5) = H33_struct.fA(5,5) + a24*a24;
H33_struct.fA(5,6) = H33_struct.fA(5,6) + a24*a25;
                                          
H33_struct.fA(6,6) = H33_struct.fA(6,6) + a25*a25;

H33_struct.Valid = false;
end

function H33_struct = H33_Compute(H33_struct)
if(H33_struct.Valid)
    return;
end

%Make Matrix Symetric 
[n,m]=size(H33_struct.fA);
B = H33_struct.fA'+H33_struct.fA;
B(1:n+1:end)=diag(H33_struct.fA);
H33_struct.fA = B;

[~,~,V] = svd(H33_struct.fA);
tmp = V(:,size(V,2));
for i = 1:3
    H33_struct.H(i,:) = tmp((i-1)*3+1:i*3);
end

H33_struct.Valid = true;
end

function [x,y, H33_struct] = H33_Project(Worldx, Worldy, H33_struct)
if(H33_struct.Valid == false)
    H33_struct = H33_Compute(H33_struct);
end
x = H33_struct.H(1,1)*Worldx + H33_struct.H(1,2)*Worldy + H33_struct.H(1,3);
y = H33_struct.H(2,1)*Worldx + H33_struct.H(2,2)*Worldy + H33_struct.H(2,3);

z = H33_struct.H(3,1)*Worldx + H33_struct.H(3,2)*Worldy + H33_struct.H(3,3);

x = (x/z) + H33_struct.cxy(1);
y = (y/z) + H33_struct.cxy(2);
end

function [x,y,H33_Struct] = Quad_interpolate01(x,y, H33_Struct)
[x,y,H33_Struct] = H33_Project(2*x-1, 2*y-1,H33_Struct);
end

function GrayModel = GM_Init()
GrayModel = struct('A',zeros(4),'v',zeros(4,1),'b',zeros(4,1),'nobs',0,'dirty',true);
end

function GrayModel = GM_addObs(x,y,gray,GrayModel)
xy = x*y;

GrayModel.A(1,1) = GrayModel.A(1,1) + x*x;
GrayModel.A(1,2) = GrayModel.A(1,2) + x*y;
GrayModel.A(1,3) = GrayModel.A(1,3) + x*xy;
GrayModel.A(1,4) = GrayModel.A(1,4) + x;
GrayModel.A(2,2) = GrayModel.A(2,2) + y*y;
GrayModel.A(2,3) = GrayModel.A(2,3) + y*xy;
GrayModel.A(2,4) = GrayModel.A(2,4) + y;
GrayModel.A(3,3) = GrayModel.A(3,3) + xy*xy;
GrayModel.A(3,4) = GrayModel.A(3,4) + xy;
GrayModel.A(4,4) = GrayModel.A(4,4) + 1;

GrayModel.b(1,1) = GrayModel.b(1,1) + x*gray;
GrayModel.b(2,1) = GrayModel.b(2,1) + y*gray;
GrayModel.b(3,1) = GrayModel.b(3,1) + xy*gray;
GrayModel.b(4,1) = GrayModel.b(4,1) + gray;

GrayModel.nobs = GrayModel.nobs + 1;
GrayModel.dirty = true;
end

function GrayModel = GM_compute(GrayModel)

GrayModel.dirty = false;

if(GrayModel.nobs >= 6)
    
    %Make Matrix Symetric 
    [n,m]=size(GrayModel.A);
    B = GrayModel.A'+GrayModel.A;
    B(1:n+1:end)=diag(GrayModel.A);
    GrayModel.A = B;
    
    GrayModel.v = GrayModel.A^-1 * GrayModel.b;
    
else
    GrayModel.v = zeros(4,1);
    GrayModel.v(4,1) = GrayModel.b(3,1) / nobs;
end
end

function [val, GrayModel] = GM_interpolate(x,y,GrayModel)
if(GrayModel.dirty)
    GrayModel = GM_compute(GrayModel);
end

val = GrayModel.v(1)*x + GrayModel.v(2)*y + GrayModel.v(3)*x*y + GrayModel.v(4);
end

function OC = OpticalCenter(height,width)
OC(2) = round(width/2);
OC(1) = round(height/2);
end

function TagDetection = TF_Decode(rCode)
bestId = -1;
bestHamming = intmax;
bestRotation = 0;
bestcode = uint64(0);

TagFamily = TagFam36h11();

rCodes = zeros(1,4);
rCodes(1) = rCode;
rCodes(2) = rotate90(rCodes(1),6);
rCodes(3) = rotate90(rCodes(2),6);
rCodes(4) = rotate90(rCodes(3),6);

for id = 1:size(TagFamily.Codes,2)
    for rot = 1:4
        
    end
end
end

function RotatedTag = Rotate90(w,d)
wr = uint64(0);
oneLongLong = uint64(1);

for r = d-1:-1:0
   for c = 0:d-1
       b = r + d*c;
       wr = bitshift(wr,uint64(1));
       if(bitand(uint64(w),bitshift(oneLongLong,uint64(b))) ~= 0)
           wr = bitor(wr,uint64(1));
       end
   end
end
RotatedTag = wr;
end

%These are helper / utility functions

% function GrayImage = cvtColor(InputImage)
% RedConv   = single(InputImage(:,:,1) *  0.299);
% GreenConv = single(InputImage(:,:,2) *  0.587);
% BlueConv  = single(InputImage(:,:,3) *  0.114);
% 
% GrayImage = RedConv + GreenConv + BlueConv;
% GrayImage = GrayImage / 255;
% end

function output = NormalizeVals(input,Max,Min)
    switch nargin
        case 1
            output = (input-min(input(:)))./(max(input(:))-min(input(:)));
        otherwise
            output = (input-Min)./(Max-Min);
    end
end

function longArray = ArraytoList(Array)
Width = size(Array,2);
Height  = size(Array,1);

longArray = zeros(1,Width*Height);
for i = 1:Height
    StartIdx = ((i-1) * Width)+1;
    EndIdx   = (StartIdx + Width)-1;
    longArray(1,StartIdx:EndIdx) = Array(i,:);
end
end

function Error = PercentError(Correct,Experimental)
difference = Experimental - Correct;
Error = abs(difference./Correct);
end
